---
title: Linux
excerpt: "我从 Windows 的世界来到了 Linux, 并且立足了。我打算分享一下我「转移」的历程和对 Linux 的看法。\r\n<h1>我的 Linux
  历程</h1>\r\n<h2>接触 Linux</h2>\r\n我之前用的是 Windows 7. 我可以在上面进行诸如硬盘分区、手动修复引导、搭建开发环境 (e.g.
  Android/Eclipse)。我曾经在一个分区上安装过 Ubuntu, 不过从来没有真正地「用」过—— 只是摆在那里，有时需要将硬盘拔下来插到其他机器上用的时候才会用上，而并不会用来日常使用。我觉得我作为一个所谓的「开发者」，迟早是要熟悉
  Linux 的，那么干脆就尝试熟悉之吧。\r\n\r\n我先使用了大概一个月的 Fedora, 然后转向了 Archlinux.\r\n<h2>进入 Linux</h2>\r\n装好
  Fedora 之后，我的 Linux 知识基本上仅限于 <code>ls</code>, <code>cat</code> 和 <code>yum</code>
  三条命令和 <code>|</code>(pipe), <code>&gt;</code>(redirection) 两个符号。不过我当时的想法是：\r\n<pre><code>尝试着用下去吧，遇到什么特定的问题再去考虑如何解决。"
wordpress_id: 970
wordpress_url: http://blog.easoncxz.com/?p=970
date: '2014-01-24 13:45:23 +1300'
date_gmt: '2014-01-24 01:45:23 +1300'
categories:
- life
- dev
tags:
- Linux
comments: []
---
<p>我从 Windows 的世界来到了 Linux, 并且立足了。我打算分享一下我「转移」的历程和对 Linux 的看法。</p>
<h1>我的 Linux 历程</h1>
<h2>接触 Linux</h2>
<p>我之前用的是 Windows 7. 我可以在上面进行诸如硬盘分区、手动修复引导、搭建开发环境 (e.g. Android/Eclipse)。我曾经在一个分区上安装过 Ubuntu, 不过从来没有真正地「用」过—— 只是摆在那里，有时需要将硬盘拔下来插到其他机器上用的时候才会用上，而并不会用来日常使用。我觉得我作为一个所谓的「开发者」，迟早是要熟悉 Linux 的，那么干脆就尝试熟悉之吧。</p>
<p>我先使用了大概一个月的 Fedora, 然后转向了 Archlinux.</p>
<h2>进入 Linux</h2>
<p>装好 Fedora 之后，我的 Linux 知识基本上仅限于 <code>ls</code>, <code>cat</code> 和 <code>yum</code> 三条命令和 <code>|</code>(pipe), <code>&gt;</code>(redirection) 两个符号。不过我当时的想法是：</p>
<pre><code>尝试着用下去吧，遇到什么特定的问题再去考虑如何解决。<a id="more"></a><a id="more-970"></a>
</code></pre>
<p>当时用的 desktop environment 是 GNOME, 所以问题不多、不严重。遇到什么问题基本上 Google 一下就能轻松解决。此阶段中，我估计我使用的电脑的功能不会比一台平板的功能多多少。这段时间里，我熟悉了诸多所谓的「常用 Linux 命令」，最典型的是 <code>less</code>, <code>man</code> 以及 Fedora 的 <code>yum</code>. （貌似值得一提的是，在 Fedora 中我没有（尝试）使用任何类似于 Ubuntu Software Center 之类的 "App Store" 类似物，而是一直在用 <code>yum</code>.）</p>
<p>我想，我应该尝试使用不同的 distro 以及不同的 DE 之后决定我喜欢哪个。在浏览各个 distro 的时候，独树一帜的 Archlinux 引起了我的注意。虽然到处号称其「新手不宜」，但是我打算至少应该装上 Archlinux, 然后看看用着如何。</p>
<h2>尝试 Archlinux</h2>
<p>对着 Archlinux 的 Beginner's Guide, 我尝试装上它。麻烦多多啊—— 当然，所有的所谓的「麻烦」只是因为我需要自己决定，并且手动实施一些在 Windows 或 Fedora 中会由「安装器」来为我、帮我做的事—— 例如分区、安装引导器、装驱动、装 GUI 、调语言和时区，诸如此类。期间，由于需要 "get hands dirty", 所以也获得了一些虽笼统但毕竟第一手的乱七八糟的经验和知识。「装好」系统后，那些比较「低层级」的问题（例如驱动、DE（虽然这个已经不太低层级了…））解决了，但是还要自己解决诸如「安装浏览器的 Flash 插件」、「安装汉字输入法、汉字字型」、「弄好 Wi-Fi 自动连接」等问题。</p>
<p>Archlinux 和 Windows 相比，从一个「普通用户日常使用」的角度，主要的区别在于 Archlinux 里基本上什么事情（「普通用户」能需要什么事情呢？[笑]）都要自己亲自解决，但是解决的方法都在 Arch Wiki 里有明确的描述与解释，并且这些方法大多使用的是「有标准可循」的。相比之下，虽然 Windows 会帮你「解决基本的问题」，但是使用的方法未必是最「标准」、最 up-to-date 的。最典型的例子还是分区和引导；如何链接不同制式的 Wi-Fi 信号也是一个例子。Windows 下使用 ThinkPad 的 TrackPoint 需要安装来自 IBM/Lenovo 的驱动程序，装好了之后就直接「就是能用」；虽然能用，但是也仅限于「能用」，不知道如何进行配置。相比之，在 Archlinux （甚至在 Fedora 中也是）中，我得自己找如何配置使用 TrackPoint, 指明用哪个键控制虚拟滚轮，滚多快，等等。</p>
<h1>Linux 之方便（与不便）（相比于 Windows）</h1>
<h2>安装软件</h2>
<p>当然，大家都能首先感受到的是 Linux 的不便吧。</p>
<p>以「××软件 Linux 上用不了」为首的「兼容性」问题不作更多讨论。要想「要做的事情是什么」，而不是「要用的工具是什么」。软件生产商不愿意制作 Linux 版本那是生产商的问题， Linux 可没有妨碍他们。正如去到法国说 "hello" 他们听不懂，要说 "bonjour" 一样，到了新环境用不了旧工具不能怪环境，只能马上学习等效的新工具。例如，「啊啊 Microsoft Office 在 Linux 上用不了怎么办？」—— 只能用 LibreOffice 了。</p>
<p>据我个人到目前为止的理解， Linux 的不便主要在于解决「安装」。把一个空白的硬盘弄上一个「弄好了，可以开始用了」的系统，需要不少功夫。</p>
<p>但是 Linux 在我作为不是一个「普通用户」，而是一个「开发者」的角度而言，十分方便。</p>
<p>在 Windows 上要安装 Python 怎么做？—— 访问 Python 官网，下载安装包，「下一步」。在 Windows 上要运行 Python 怎么做？要么在开始菜单中找到 "python command line", 要么「右键点击『计算机』，『属性』之类的，找『环境变量』……(&amp;^$#…，然后打开 cmd 执行 <code>python</code> 命令」。而在 Linux 下呢？打开命令行执行一条命令 <code>sudo pacman -S python</code> 就安装好了，接着一条 <code>python</code> 命令就运行起来了。哪个方便？</p>
<p>我去听一个什么 Python 开发者会议；会议介绍一个叫做 Twisted 的什么网络工具，让我们在电脑上安装。在 Windows 上，我得找 Twisted 的官网，然后找到我要的到底是哪个安装器，下载了「下一步」了之后还要考虑是否需要配置什么东西才能让新装的 Twisted 被 Python 找到。在 Linux 下呢？我尝试搜索：<code>pacman -Ss twisted</code>—— 诶？找到了有喔！然后 <code>sudo pacman -S twisted</code> 就装好了，运行下 python -c "import twisted" 果然已经在了。哪个方便？</p>
<p>我想在 GitHub Pages 上做一个小静态网站，发现可以用 Jekyll 生成。要装好 Jekyll 以备我使用，在 Linux 上我只须最多两条命令即可：如果之前没有装上 python 和 ruby 的话，用一条 <code>pacman</code> 命令装上；然后用一条 <code>gem</code> 命令就可以装完 Jekyll 了。从发现这个工具到用上它</p>
<p>我想尝试 C 语言编程。 C 语言不是偏僻奇怪或新鲜激进的语言了，同时也并不落后。然而我至今没弄懂（我的确是尝试过的）如何在 Windows 机器上弄到一个 C 编译器（注意，我说的不是 IDE ，那玩意太大了）。 Linux 下弄个 C 编译器又有多困难呢？又是一条命令 <code>sudo pacman -S gcc</code> 就好了。打开文本编辑器写个 Hello World, 马上就能编译了。</p>
<p>甚至在一些「普通用户」领域的事情，Linux 还是要比 Windows 方便。例如「安装 Firefox 」：Windows 又是一串「访问网站-&gt;下载-&gt;下一步」的操作，而 Linux 又只是一条命令。</p>
<p>更大的问题是安装之后（而不是如何安装）—— 软件更新。Windows 里的软件总是一个个争先恐后要自己联网检查是否存在更新，然后自己弹窗口给用户点。Linux 呢？如今大多数（如果不是「所有」的话）distro 已经有各自的「包管理器」了，例如 pacman 。又是一条命令 <code>pacman -Syu</code> ，整个系统的所有（通过这个包管理器安装的）软件，下至内核，上至屏保，全部都会更新。是不是更新之容易有如 Google Play 或者 App Store 呢？</p>
<h2>生态，或者称「软件间的关系」</h2>
<p>Windows 是一个平台上，各个软件各自为伍、自扫门前雪。没有哪个软件是依赖于另外的软件的，也没有哪个软件是设计来给别的软件「打下手」）—— 而不是给最终用户使用的。这没有什么必然的坏处，不过肯定会出现重复的功能（同一个功能，不同的软件不同地提供），潜在用户使用方式不一致的问题。其实说白了就是土，没有标准，各家想怎样就怎样，想给你个通知我就自己写个弹窗啥的。</p>
<p>Linux 是一个平台上，不同的软件行程了一个小社区，不同的软件之间有很强的依赖关系。比如我可以安装一个屏保，然后跟我管屏保的 软件/设置 说，「嗨，我换屏保软件了，下回要用屏保你去找这个新的屏保提供者啊」。比如安装了网络链接管理器之后，管理器告诉我：「如果你想让我们给你提供弹出窗口的话，请你装上我们另外这个弹窗器，它能识别你的 DE 的弹窗管理器的标准接口，将我们要弹的消息交给你的 DE 处理」。</p>
<p>Linux 上一个我觉得特别强大的例子是 Sage. 我以前就知道 Octave 可以大概代替 MATLAB, Maxima 可以大概代替 Mathematica, 但是我后来才发现有个特牛逼的包叫 Sage 的，直接整合了 Maxima 和 Octave 以及若干个另外的计算工具，封装好一并提供给用户。虽然估计这种整合是光有命令行所无法达到的，需要 Sage 的那群开发者利用 Octave, Maxima 等软件所具有的 Linux 的「开源」这一特性，但是我觉得这是 Linux 下软件<strong>合作</strong>的很好的例子。</p>
<p>我难以总结 Linux 这种「标准化」、「社区性」的好处，但是至少，如果我不喜欢某个软件（例如我的 DE ），如果存在其他与其接口一致的软件，我可以换成那个来用而不用触动依赖于这个软件的其他软件。提倡 Linux 的某群人整天说「自由」—— 这里的例子算是用户选择什么软件来用的自由了吧。</p>
<h2>完成任何任务</h2>
<p>Linux 相比于 Windows 强大的一个特征，就是所有的系统、软件、用户都有很强的「命令行」传统。即使是提供 GUI 的软件，往往其低层是先有一个 CLI 提供了功能之后，再用 CLI 作为一个 abstraction barrier 来写图形界面。</p>
<p>命令行有什么好处呢？</p>
<p>人们都说什么「高效」，什么「知识大于导航」。我不反对。我想指出另一点：命令行文化的盛行相当于（有 CLI 的）任何软件都能够与其他所有（有 CLI 的）软件进行交互、都有对方的 API ，能够共同完成一个任务。这意味着，我可以通过一套指令，令各种不同的软件共同完成一个任务。<strong>软件之间可以合作</strong>。</p>
<p>最近我作的一个事情就是<a href="https://twitter.com/easoncxz/status/425416798758907904">下载 CS61A 的讲座视频</a>。我先获得了一个含有 CS61A 的视频 YouTube 地址信息、讲义 PDF 、作业等所有信息的 JSON 文件，然后用 python 解读 JSON 获取其中的视频地址，然后将地址交给 youtube-dl 来下载。如果我希望的话，我可以将一个个命令写在一个脚本里，交给 shell 去一起执行。这体现了软件间的合作。由于软件间可以合作，无论是什么（用自然语言描述起来会很）复杂的任务，只要我能在命令行上用各种 pipe, redirection, 文件读写等各种渠道，（用形式语言）描述出我要做的事情，那么事情总是可以「一下子」做好。</p>
<p>（「一下子」的含义是「常数时间复杂度」—— 解决问题所需的时间不会随着问题「大小」的增加而增加—— 手动修改 10 个文件的文件名需要修改 5 个的时间的两倍那么多的（人为操作）时间，但是如果用命令行脚本描述出我到底是要怎么改这些文件名，那么无论是 10 个文件还是 2000 个那样的文件，我都只需要执行一次这个脚本。）</p>
<p>简单地说，「懂得命令行，你说的出的他就做得到」。</p>
<h1>后话</h1>
<p>Linux （尤其是 Archlinux ）很多时候的确使得一些「日常」任务「麻烦」起来，但是在真的要做些事情的时候，比 Windows 方便了不止一点。这个代价获得这个好处，很值。顺便还能令自己使用电脑的注意力从「如何用电脑」或多或少地转向「用电脑干嘛」上去，而我认为这是好事。</p>
